plugins {
    id 'java'
    id 'application'
    id 'checkstyle'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
    id 'jacoco'
}

repositories {
    mavenCentral()
}

dependencies {
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.10.0'
    testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.10.0'
}

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
    enableAssertions = true
    testLogging {
        events "passed", "skipped", "failed"

        showExceptions true
        exceptionFormat "full"
        showCauses true
        showStackTraces true
        showStandardStreams = false
    }
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }

    doLast {
        def xmlFile = reports.xml.outputLocation.get().asFile

        try {
            def parser = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder()
            // Disable DTD validation to avoid external DTD issues
            parser.setEntityResolver({ publicId, systemId ->
                return new org.xml.sax.InputSource(new java.io.StringReader(""))
            })

            def doc = parser.parse(xmlFile)
            def reportElement = doc.documentElement

            // Parse per-class coverage first
            println ""
            println "========================================="
            println "PER-CLASS COVERAGE REPORT"
            println "========================================="

            def packages = doc.getElementsByTagName("package")
            for (int p = 0; p < packages.getLength(); p++) {
                def packageNode = packages.item(p)
                def packageName = packageNode.getAttribute("name")

                // Only show main source packages (exclude test packages)
                if (!packageName.contains("test")) {
                    def classes = packageNode.getElementsByTagName("class")
                    for (int c = 0; c < classes.getLength(); c++) {
                        def classNode = classes.item(c)
                        def className = classNode.getAttribute("name")

                        // Extract just the class name from the full path
                        def simpleClassName = className.substring(className.lastIndexOf('/') + 1)

                        def classCounters = classNode.getChildNodes()
                        def instructions = null
                        def branches = null

                        for (int i = 0; i < classCounters.getLength(); i++) {
                            def node = classCounters.item(i)
                            if (node.getNodeName() == "counter") {
                                def type = node.getAttribute("type")
                                if (type == "INSTRUCTION") {
                                    instructions = node
                                } else if (type == "BRANCH") {
                                    branches = node
                                }
                            }
                        }

                        if (instructions) {
                            def missed = instructions.getAttribute("missed") as Integer
                            def covered = instructions.getAttribute("covered") as Integer
                            def total = missed + covered
                            def percentage = total > 0 ? (covered * 100.0 / total) : 0

                            def branchInfo = ""
                            if (branches) {
                                def branchMissed = branches.getAttribute("missed") as Integer
                                def branchCovered = branches.getAttribute("covered") as Integer
                                def branchTotal = branchMissed + branchCovered
                                def branchPercentage = branchTotal > 0 ? (branchCovered * 100.0 / branchTotal) : 0
                                branchInfo = ", Branches: ${String.format("%.1f", branchPercentage)}% (${branchCovered}/${branchTotal})"
                            }

                            println "${simpleClassName}: Instructions: ${String.format("%.1f", percentage)}% (${covered}/${total})${branchInfo}"
                        }
                    }
                }
            }

            // Get the direct children counters of the report element (these are the aggregated totals)
            def reportCounters = reportElement.getChildNodes()
            def instructions = null
            def branches = null

            for (int i = 0; i < reportCounters.getLength(); i++) {
                def node = reportCounters.item(i)
                if (node.getNodeName() == "counter") {
                    def type = node.getAttribute("type")
                    if (type == "INSTRUCTION") {
                        instructions = node
                    } else if (type == "BRANCH") {
                        branches = node
                    }
                }
            }

            if (instructions) {
                def missed = instructions.getAttribute("missed") as Integer
                def covered = instructions.getAttribute("covered") as Integer
                def total = missed + covered
                def percentage = total > 0 ? (covered * 100.0 / total) : 0

                println ""
                println "========================================="
                println "OVERALL COVERAGE SUMMARY"
                println "========================================="
                println "Instructions: ${String.format("%.1f", percentage)}% (${covered}/${total})"

                if (branches) {
                    def branchMissed = branches.getAttribute("missed") as Integer
                    def branchCovered = branches.getAttribute("covered") as Integer
                    def branchTotal = branchMissed + branchCovered
                    def branchPercentage = branchTotal > 0 ? (branchCovered * 100.0 / branchTotal) : 0
                    println "Branches: ${String.format("%.1f", branchPercentage)}% (${branchCovered}/${branchTotal})"
                }
            } else {
                println "Could not find aggregated INSTRUCTION counter in report"
            }

        } catch (Exception e) {
            println "Could not parse coverage details: ${e.message}"
        }

        println ""
        println "HTML Report: ${reports.html.outputLocation.get().asFile.toURI()}"
        println "XML Report: ${reports.xml.outputLocation.get().asFile.toURI()}"
        println "========================================="
    }
}


jacoco {
    toolVersion = "0.8.8"
}

application {
    mainClass.set("seedu.studymate.StudyMate")
}

shadowJar {
    archiveBaseName.set("studymate")
    archiveClassifier.set("")
}

checkstyle {
    toolVersion = '10.2'
}

run {
    standardInput = System.in
    enableAssertions = true
}
